
# Jogo da Forca (C#)

Um projeto de um Jogo da Forca feito em C#.

No decorrer deste projeto - _que fiz pois estava com tempo livre antes de ir √† faculdade_ - vamos entender, bem por cima, (at√© porque n√£o √© minha inten√ß√£o ensinar a o desenvolver) o funcionamento essencial de um projeto de mesmo n√≠vel ao de um **jogo da forca**.

## ‚åö Antes de iniciar o projeto
First things first, antes de ja ir colocando a m√£o na massa e codar, precisamos entender as regras e o funcionamento do jogo.

_"Ah, mas √© um jogo da forca... As regras s√£o bem intuitivas"_

Sim, realmente √©. Mas de qualquer forma √© preciso deixar isso bem definido pois quando for de fato programar, possa colocar sua l√≥gica em pr√°tica e assim conseguir refletir o m√°ximo das regras do jogo **e at√© implementar as suas pr√≥prias** - _como eu fiz_ - e ter um joguinho ainda mais com a sua cara üòÅ

√â preciso tamb√©m, definir o que √© importante para o funcionamento do jogo. No caso deste projeto, o jogo foi feito com uma interface oriunda do Windows Forms que, a grosso modo, √© uma estrutura de interface de usu√°rio (UI) que cria aplicativos de Desktop avan√ßados para Windows atrav√©s de um designer virtual com mecanismo de edi√ß√£o **_Drag and Drop_** (ou **Arrastar e Soltar**, em portugu√™s). Se nunca ouviu falar disso, ent√£o recomendo pesquisar e estudar um pouco antes de prosseguir, pois este projeto utiliza fortemente de recursos presentes somente nesta estrutura de cria√ß√£o de design.

#### üìñ  Regras da Forca
O jogo da forca √© composto por regras simples, de acordo com a **Wikip√©dia**
>O jogo da forca √© um jogo em que o jogador tem que acertar qual √© a palavra proposta, tendo como dica o n√∫mero de letras e o tema ligado √† palavra. A cada letra errada, √© desenhado uma parte do corpo do enforcado. O jogo termina ou com o acerto da palavra ou com o t√©rmino do preenchimento das partes corp√≥reas do enforcado.

Para come√ßar o jogo se desenha uma base e um risco correspondente ao lugar de cada letra.
Por exemplo, para a palavra "MELANCIA", se escreve:
M E L A N C I A ------> _ _ _ _ _ _ _ _
>O jogador que tenta adivinhar a palavra deve ir dizendo as letras que podem existir na palavra. Cada letra que ele acerta √© escrita no espa√ßo correspondente.

M E L A N C I A ------> _ E _ A _ _ I A
>Caso a letra n√£o exista nessa palavra, desenha-se uma parte do corpo (iniciando pela cabe√ßa, tronco, bra√ßos‚Ä¶)

Como no exemplo dessa imagem abaixo
![regra_forca](https://user-images.githubusercontent.com/43553717/159046745-950b5b94-7c13-4cfa-90ea-f06a7c7db333.gif)
**Nesse projeto, o jogador ter√° apenas 7 chances de tentar acertar a palavra** (_para deixar o jogo um pouco mais emocionante_ üòè).
>O jogo √© ganho se a palavra √© adivinhada. Caso o jogador n√£o descubra qual palavra √© ele que perde.

E eu tomei a liberdade de adicionar mais algumas funcionalidades no jogo, como: 
- a continuidade do jogo (com uma palavra diferente mas do mesmo tema) caso o jogador acerte a palavra atual;
- pontua√ß√£o acrescidos conforme o jogador acerta as palavras;
- possibilidade de continuar jogar novamente do in√≠cio caso o jogador perca o jogo;
- possibilidade de troca de palavra para outra do mesmo tema somente uma vez por rodada e na troca o n√∫mero de tentativas √© subtra√≠do por 2;
- pedir at√© 3 dicas, desde que a quantidade de letras reveladas seja inferior a 3 e que a palavra tenha mais de 4 letras em sua composi√ß√£o.

Voc√™ pode tomar a mesma liberdade e definir mais regras - _mas pelo amor de Alan Turing, **nunca mude a ess√™ncia do jogo**_ - e assim deix√°-lo mais divertido.

## üîß Colocando a m√£o na massa
Imagino que deve estar pensando:
>_"Finalmente come√ßamos os t√≥picos de programa√ß√£o"_

Acalme-se, meu caro leitor. Existem algumas etapas a serem seguidas antes de programar. Essas etapas _- por mais chatas que pare√ßam -_ fazem parte do desenvolvimento de um sistema (mesmo que indiretamente). Uma hora ou outra vamos nos deparar e ter que lidar com elas no decorrer do projeto.

Como no exemplo da regra acima;
> Caso a letra n√£o exista nessa palavra, desenha-se uma parte do corpo (iniciando pela cabe√ßa, tronco, bra√ßos‚Ä¶)

temos que j√° ter em mente que precisamos das figuras representanda pelo numero de erros do jogador. Se preferir, pode baixar os sprites da internet. Neste projeto, foi desenhado cada sprite em um programa de desenhos muito poderoso _- vulgo paint -_ **para seguir com o tema do design** _- que foi voltada a um contexto e ambienta√ß√£o mais r√∫stica (aguarde os pr√≥ximos capitulos) -_ primeiro √© desenhado a forca, depois a cabe√ßa, o corpo, os bra√ßos e as pernas assim por diante como no exemplo abaixo.
|Sprite 1 | Sprite 2| Sprite 3 | Sprite 4| Sprite 5 | Sprite 6| Sprite 7 | Sprite 8 |
|-------- | --------| -------- | --------| -------- | --------| -------- | -------- |
| ![FORCA_0](https://user-images.githubusercontent.com/43553717/159053384-f1a87e4e-46a1-4d8b-a93c-4ae092326553.png) | ![FORCA_1](https://user-images.githubusercontent.com/43553717/159053723-af3b2590-e152-455d-92d3-ff074cdd1986.png) | ![FORCA_2](https://user-images.githubusercontent.com/43553717/159053934-2d270ed9-25a3-4964-9b83-96d0c80c35bf.png) | ![FORCA_3](https://user-images.githubusercontent.com/43553717/159053979-55146a90-d931-4321-8b22-5e42fef1cec0.png) | ![FORCA_4](https://user-images.githubusercontent.com/43553717/159054199-5e333f97-3c74-4c6a-af62-c151a89cef2c.png) | ![FORCA_5](https://user-images.githubusercontent.com/43553717/159054225-64e3babb-3503-4c3e-a6a5-17a1f597946f.png) | ![FORCA_6](https://user-images.githubusercontent.com/43553717/159054263-8bd1311f-5507-4bab-9dfe-0f851212f197.png) | ![FORCA_7](https://user-images.githubusercontent.com/43553717/159054364-36492481-c6ff-4691-9a40-324f0eac3c93.png)

_-Lembrando que, para facilitar a programa√ß√£o, cada sprite deve ser salva em arquivos diferentes._

Logo ap√≥s ter as sprites, √© hora de criar uma interface legal para o jogo. Como dito anteriormente, a prim√≠cia do design deste projeto foi algo mais rustico, como um jogo desenhado a lapis em um caderno. Nada muito complexo ou imaginado. Como √© mostrado nos exemplos abaixo.
![INTERFACE_JOGO_FORCA_4](https://user-images.githubusercontent.com/43553717/159720175-3bf34692-fda1-40c1-bf49-6014d67ba87b.jpg)   ![INTERFACE_JOGO_FORCA_3](https://user-images.githubusercontent.com/43553717/159079515-7f2011cc-5965-4bcb-a50c-c8b801eb2717.jpg) 
![INTERFACE_JOGO_FORCA_5](https://user-images.githubusercontent.com/43553717/159725740-0b1e1b17-b285-4c17-87a1-7eb2f51eae02.jpg)


_- novamente volto a refor√ßar que a inten√ß√£o deste artigo n√£o √© ensinar a desenvolver o projeto, e sim passar o seu funcionamento a limpo e tornar visual o que para quem for visualizar este reposit√≥rio sem a necessidade de fu√ßar pelo reposit√≥rio._

## üíª Coding Time
Finalmente! Chegamos no t√≥pico t√£o esperado deste projeto. a **PROGRAMA√á√ÉO** do jogo. A parte onde daremos vida ao nosso projeto.
A programa√ß√£o deste projeto _- como de qualquer outro que envolva programa√ß√£o -_ foi dividida em 3 partes (como √© poss√≠vel ver na interface desse programa na imagem acima):
- Defini√ß√£o de necessidades do c√≥digo;
- Entrada de dados;
- Processamento e manipula√ß√£o dos dados de entrada;
- Retorno da sa√≠da dos dados processados.

##### üìù Defini√ß√£o de necessidades do c√≥digo
Esta etapa diz respeito a todas as propriedades e funcionalidades que ser√£o essenciais para o funcionamento do c√≥digo, tais como o numero de tentativas do jogador, sua quantidade de acertos, o m√°ximo de tentativas permitidas pelo programa, quantidade de pontos e as localiza√ß√µes das sprites de cada erro do jogador e entre outras. Confira na imagem abaixo como esse projeto define essas necessidades:
![CODING_DEFINICAO_NECESSIDADE_1](https://user-images.githubusercontent.com/43553717/159718257-01047ebf-e805-44ca-a720-4d0dbf4a3dc4.jpg)

A propriedade mais importante para definir qual sera a ``palavraAtual``, no contexto das regras deste projeto, seria **o tema da palavra esolhida**. No caso deste projeto, **o tema da palavra gerada √© definido de acordo com a escolha do usu√°rio na primeira vez que iniciar o jogo** atrav√©s da interface "ESCOLHA UM TEMA" definida na primeira imagem de exemplo de cria√ß√£o da interface citado anteriormente. Em sumo, o jogador escolhe um tema e este tema ser√° atribuido √† variavel ``temaAtual``.

Todas as vezes que o programa inicializar, deve criar um novo jogo com estas mesmas propriedades inicializadas de acordo com as regras. Esta parte da programa√ß√£o deste projeto est√° definido pela fun√ß√£o ``novoJogo()`` conforme a imagem abaixo;
![CODING_DEFINICAO_NECESSIDADE_2](https://user-images.githubusercontent.com/43553717/160299173-00ed0cb1-4156-492e-8e59-bf98cd216dd0.jpg)

Resumidamente, esta fun√ß√£o √© respons√°vel por inicializar um novo jogo (indiferente de ser a primeira vez do jogador) e **atribui √†s propriedades de inicializa√ß√£o definidas na interface e tratadas pelo programa (como √© visto nas tr√™s primeiras linhas da fun√ß√£o) os seus devidos valores**, isso porque essa fun√ß√£o √© din√¢mica e n√£o √© chamada somente na inicializa√ß√£o e sim em varios outros momentos no decorrer do programa. Logo ap√≥s uma nova palavra √© gerada atrav√©s do m√©todo ``gerarPalavra()`` e **√© atribuida a palavra atual atrav√©s de uma busca e escolha aleat√≥ria em uma das listas de palavras (separadas pelos temas dispon√≠veis) salvos em arquivos de textos diferentes** conforme mostrado na imagem abaixo.
![CODING_DEFINICAO_NECESSIDADE_4](https://user-images.githubusercontent.com/43553717/159729317-7ba6e375-00a6-4374-bda5-6918d2cf7838.jpg)
Repare que, ao atribuir o nome do arquivo ao identificador de recurso (URI), √© chamado a fun√ß√£o de tratamento ``handleTemaURI(string temaAtual)``, isso pois **o tema da escolha do jogador pode ter acentos** (como em PROFISS√ÉO) e, por boa pr√°tica _- e por n√£o ser um completo lun√°tico -_, **os arquivos salvos tem a formata√ß√£o de texto universal**, isto √©, **n√£o possu√≠ acentos em sua composi√ß√£o ou espa√ßos em branco ou caracteres especiais (com exce√ß√£o de "-" ou "_")** e esse essa fun√ß√£o trata exatamente isso.
Outra coisa importante de se mencionar √© que de acordo com a l√≥gica da fun√ß√£o, se o jogador acertar a palavra e continuar o jogo, **as chances da nova palavra ser repetida diminuiem em 100%** at√© que ele tenha completado todas as palavras da lista.

Continuando com o m√©todo ``novoJogo()``, em seguida, a sprite da forca, quantidade de tentativas e acertos √© configurada aos seus valores iniciais respectivamente. Abaixo temos o m√©todo ``statusButton(boolean)`` que √© um m√©todo que percorre o contexto atual procurando por bot√µes e os ativando ou desativando de acordo com o par√¢metro (``true`` ativa os bot√µes e ``false`` os desativa) _- isso porque toda vez que o jogador escolhe uma letra o bot√£o √© desativado sendo necess√°rio reativar todos eles novamente_.
Logo abaixo temos a parte interessante, √© onde trocamos a correspond√™ncia das letras da palavra por underlines (de acordo com as regras universais do jogo citadas anteriormente) atrav√©s do m√©todo ``esconderCorrespondencia()``. Para isso, um la√ßo de repeti√ß√£o √© criado que ser√° iterado at√© o final da palavra atual e em cada itera√ß√£o, √© gerado uma nova ``Label`` com o valor do texto representado por um underline (*"_"*) e sua estiliza√ß√£o tamb√©m definida gerando esse resultado final:
![CODING_DEFINICAO_NECESSIDADE_3](https://user-images.githubusercontent.com/43553717/159340871-ad8a682d-e6be-4f62-96a2-a470dd19d7a6.jpg)

Repare que este m√©todo lida com a responsividade das palavras, isso √©, caso a palavra for maior que um determinado numero de letra, cada letra tende a diminuir o tamanho da ``Label`` ou da fonte de texto _- que √© o caso deste projeto -_ e assim consegue "encaixar" a palavra dentro do painel no qual a letra est√° localizada. Legal, n√£o √©? üôÇ

##### üì• Entrada de dados
A parte de entrada de dados ser√° **encarregada a capturar todos os dados "crus" podendo ou n√£o serem tratadas inicialmente antes de serem enviadas para a parte respons√°vel pela manipula√ß√£o** _- quando se tem a separa√ß√£o distinta destas etapas, eu pessoalmente prefiro verificar e tratar os dados antes de se enviar para a parte de processamento pois dessa forma fica bem n√≠tido a fun√ß√£o de cada parte._

As entradas de dados deste projeto, como j√° deve ser claro a este ponto, √© representada pelo conjunto dos bot√µes na interface, onde o usu√°rio poder√° interagir na inten√ß√£o de ter um problema solucionado _- claro que essa intera√ß√£o varia de acordo com o contexto do programa -_
![INTERFACE_ENTRADA_DE_DADOS](https://user-images.githubusercontent.com/43553717/159292007-d6546578-78af-48e4-94f8-5fc8685a6a45.jpg)
Cada bot√£o √© objeto com propriedades, m√©todos e eventos a serem tratados ou utilizados conforme a necessidade do programa e o decorrer da programa√ß√£o. 
Neste caso, n√≥s estamos interessados em capturar o **evento de clique do bot√£o** (que √© representado pela forma do jogador escolher uma poss√≠vel letra presente na palavra). 
Tamb√©m precisamos achar a identidade de cada bot√£o, pois para o programa eles n√£o passam de um conjunto de objetos que s√£o inst√¢ncias de uma mesma classe, ent√£o **como vamos saber se o usuario clicou no bot√£o equivalente a letra A ou a letra B?** Bom, h√° varias formas de identificarmos um bot√£o com essa inten√ß√£o, mas para ficar mais f√°cil, nesse caso usaremos somente o **texto presente em cada bot√£o** como uma conven√ß√£o e assim definir a identidade do bot√£o.
E essa explica√ß√£o toda √© traduzida em c√≥digo de acordo com a imagem abaixo
![CODING_ENTRADA_DE_DADOS_1](https://user-images.githubusercontent.com/43553717/160291884-67dc418e-962f-4802-a3c2-0a619887cc5f.jpg)

A primeira linha do c√≥digo √© utilizada somente para atribuir o foco atual para outro contexto fora do bot√£o _- com a simples finalidade de ficar mais bonitinho -_ e, seguindo abaixo, **temos a inst√¢ncia do bot√£o oriunda de object sender vindo do par√¢metro da fun√ß√£o chamada no evento de clique do objeto** e veja, neste caso n√£o foi necess√°rio nenhuma verifica√ß√£o ou tratamento antes de passar para a etapa de processamento de dados, isso porque esse m√©todo ser√° chamado SOMENTE quando algum dos 26 bot√µes (representados pelas letras do alfabeto) for clicado, por ser um m√©todo **bem espec√≠fico** e **dentro de um contexto bem definido e controlado**, n√£o tem a necessidade de fazer verifica√ß√µes, valida√ß√µes ou tratamentos dos dados.

Logo abaixo da inst√¢ncia temos duas linhas utilizadas para estiliza√ß√£o e l√≥gica respectivamente. Primeiramente a borda do bot√£o ser√° afinada **indicando visualmente que o bot√£o clicado atualmente foi de fato clicado** e tamb√©m o **diferenciando dos que n√£o foram clicados pois tem a borda mais grossa** e logo em seguida o bot√£o √© desativado pois, de acordo com a l√≥gica do jogo **n√£o se pode escolher mais de uma vez a mesma letra** _- primeiro porque se uma letra pertence a solu√ß√£o, todas as suas compatibilidades devem ser trocadas e reveladas e segundo pois ora, se a letra n√£o perten√ße a solu√ß√£o, √© il√≥gico tentar novamente com a mesma letra e insistir no erro  -_ e logo em seguida, o texto presente no bot√£o (representando a identidade do mesmo, equivalente a letra escolhida pelo usu√°rio) √© recuperado pela propriedade `` Text `` presente em `` Button `` e enviado para o m√©todo de processamento de dados `` manipularEscolha() ``.

##### üî® Processamento e sa√≠da de dados
E √© aqui que est√° presente o cora√ß√£o do projeto. Olhe a imagem abaixo da fun√ß√£o `` manipularEscolha() `` chamada na etapa anterior;
![CODING_PROCESSAMENTO_DE_DADOS_1](https://user-images.githubusercontent.com/43553717/160298731-4bb203e5-5db6-4a2e-8be1-97305fd58465.jpg)

Primeiramente, temos um la√ßo de repeti√ß√£o que, talvez, seja a parte mais importante do processamento de dados. Aqui √© onde ocorre a verifica√ß√£o para identificar se a **letra escolhida** pelo jogador est√° presente na **palavra gerada** _- guardada dentro da vari√°vel ``palavraAtual``_. Mas tamb√©m n√£o h√° nenhum mist√©rio em seu funcionamento, o la√ßo de repeti√ß√£o percorre toda a palavra e a cada itera√ß√£o verifica se a letra da vez corresponde a letra esolhida pelo jogador. Caso seja verdadeiro, a vari√°vel local ``acertou`` recebe ``true`` _- para, no decorrer do programa. identificar se o la√ßo chegou ao final sem que ele acerte uma letra o que √© verificado logo abaixo-_ e, na primeira linha dentro do la√ßo de repeti√ß√£o, h√° uma atribui√ß√£o de um caracter ``letraAtual`` provinda da fun√ß√£o ``verificarCodificacao()``. 
Eis o problema: n√≥s, brasileiros, utilizamos um sistema de codifica√ß√£o um pouco diferente do padr√£o universal (americano) em nosso sitema de comunica√ß√£o escrita, isto √©, nossas palavras s√£o um pouco diferentes das do restante do mundo _-- assim como algumas outras linguas como chin√™s ou √°rabe, mas n√£o estamos interessados nelas --_ e por isso devemos nos atentar √† estas palavras e trocar √† sua correspondente letra. Por exemplo a palavra **MACARR√ÉO** ela posui um **A** com uma acento til( **~**) gerando a letra **√É**. E isto √© um prolema, pois na nossa interface n√£o colocamos op√ß√µes de acentua√ß√£o para o usu√°rio escolher. Ent√£o como resolver este problema? √â a√≠ que o m√©todo ``verificarCodificacao()`` entra. Ele √© um m√©todo que troca a letra com acentua√ß√£o pela sua respectiva letra base sem acento... Os caracteres **[√É, √Å, √Ä, √Ç, ...]** por exemplo, s√£o trocados pelo **A**, assim como os caracteres **[√â, √à, √ä, ...]** s√£o trocados pelo **E**. Assim como √© mostrado na descri√ß√£o da fun√ß√£o abaixo.
![CODING_PROCESSAMENTO_DE_DADOS_3](https://user-images.githubusercontent.com/43553717/160292968-c69c6fb8-9fa8-42e1-84ec-2d43a3752c09.jpg)
Pronto, at√© aqui temos tudo em ordem no controle da acentua√ß√£o üôÇ

Agora, voltando com o m√©todo ``manipularEscolha()`` a letra retornada do processamento da fun√ß√£o ``verificarCodificacao()`` √© passada para a verifica√ß√£o na linha imediatamente abaixo comparando com a letra escolhida pelo jogador vinda do parametro ``control`` e, caso a verifica√ß√£o for verdadeira, **√© atribuido verdadeiro √† variavel local ``acertou``, os acertos s√£o acrescidos e a fun√ß√£o ``mostrarLetra()`` √© chamada**. 
Essa fun√ß√£o √© bem simples, **ela percorre o contexto onde est√£o as ``Labels`` geradas anteriormente em ``novoJogo()`` e acresce um index toda vez que ele for menor que a posi√ß√£o passada no par√¢metro do m√©todo (primeiro par√¢metro)**, _- podendo assim identificar qual a pocis√£o da palavra atual corresponde a letra que o jogador acertou -_ e, quando o index corresponder ao par√¢metro da posi√ß√£o **a ``Label`` correspondente dentro deste contexto receber√° o texto equivalente ao caracter da posi√ß√£o atual que o jogador acertou presente na vari√°vel ``palavraAtual`` (segundo par√¢metro)**.
E, voltando na primeira verifica√ß√£o do la√ßo de repeti√ß√£o, ele n√£o pode parar assim que achar a primeira letra pois se existir mais de uma correspond√™ncia de letra para a palavra atual, **TODAS ELAS DEVEM SER TROCADAS** _- como √© descrito nas regras do jogo. Viu como √© bom definir tudo antes de colocar a m√£o na massa? Fica a dica_ üòâ -  como no exemplo da palavra **"MACARR√ÉO"**.

No momento atual, ela est√° correspondendo somente √† **"_ _ _ _ _ _ _ _"**.

Vamos supor que o jogador escolha a letra **"A"**.
Este la√ßo de repeti√ß√£o deve iterar cada posi√ß√£o da palavra atual **at√© o final da palavra**, podendo assim identificar se a letra escolhida pelo jogador est√° presente _- independente da codifica√ß√£o da palavra, pois tratamos isso anteriormente -_ na palavra atual. **E est√°!** Tr√™s vezes ainda. Ou seja, **as defini√ß√µes de acerto devem ser feitas 3 vezes**, isso √©, **acertou 3 letras presentes na palavra e deve-se mostrar estas 3 letras em suas respectivas posi√ß√µes.** 

Deixando o jogo com a solu√ß√£o parcial: **"_ A _ A _ _ √É _"**.

Prosseguindo com a fun√ß√£o logo abaixo do m√©todo ``mostrarLetra()`` temos uma verifica√ß√£o para desativar o bot√£o da dica caso a quantidade de acertos for maior ou igual a 3 (como solicitado na regra 5) _- abordaremos a quest√£o da dica mais tarde -_ e logo abaixo, temos a segunda verifica√ß√£o que trata caso o jogador **n√£o tenha acertado nenhuma letra e a posi√ß√£o de itera√ß√£o do la√ßo de repeti√ß√£o estiver no final da palavra** em outras palavras, o jogador infelizmente errou ao escolher a letra pois ela n√£o est√° presente em nossa solu√ß√£o parcial üò™.
√â chamado ent√£o o m√©todo ``errou()`` que **acresce uma tentativa** pois, conforme solicitado na regras do jogo, o jogador s√≥ explicitamente perdeu uma tentativa quando a letra escolhida n√£o est√° presente na resolu√ß√£o da palavra e tamb√©m **muda a sprite da forca**, desenhando mais um peda√ßo do corpo do boneco a ser cruelmente enforcado.

E, finalizando o m√©todo ``manipularEscolha()``, temos duas verifica√ß√µes finais.
A primeira verificado, atrav√©s da fun√ß√£o ``ganhou()``, √© chamada para identificar se a **quantidade de acertos da palavra atual √© igual ao tamanho real da palavra atual** _- desta forma, n√≥s conseguimos saber se ele acertou todas as letras presente na palavra -_ e caso seja verdadeiro, a quantidade de pontos √© acrescida (conforme solicitados na regra 2) e um novo jogo √© chamado atrav√©s da fun√ß√£o ``novoJogo()`` da qual j√° trabalhamos nos t√≥picos anteriores. Esta fun√ß√£o √© chamada sempre que o jogo voltar ao estado inicial sendo elas **na primeira vez que o programa for inicializado**, **quando acertar uma palavra** (conforme solicidado na regra 1) ou **quando o jogador perder o jogo por√©m deseja jogar novamente** (conforme solicitados na regra 3).

E ultima verifica√ß√£o √© chamada para identificar caso o jogador **perdeu o jogo** atrav√©s da fun√ß√£o ``perdeu()`` que verifica **se o numero de tentativas do jogador for igual ao m√°ximo de tentativas permitidas pelo jogo** e caso seja verdadeiro, a fun√ß√£o ``fimDeJogo()`` √© chamado. A fun√ß√£o ``fimDeJogo()`` abre uma **janela personalizada** _- semelhante a de esolha de tema, por√©m menor e mais controlada quanto √† posi√ß√£o -_ √© mostrada ao jogador questionando se ele deseja jogar novamente juntamente com a quantidade de pontos que ele adquiriu ao decorrer dos jogos. Confome √© visto na imagem abaixo.
![INTERFACE_JOGO_FORCA_5](https://user-images.githubusercontent.com/43553717/159725740-0b1e1b17-b285-4c17-87a1-7eb2f51eae02.jpg)

E por √∫ltimo, mas n√£o menos importante, temos os dois bot√µes mais chamativos dessa linda interface, a **DICA** e **TROCAR**.

Primeiramente, vamos abordar a **dica**. Conforme solicitado nas regras, a dica deve eliminar ao jogador as correspond√™ncias de uma letra presente na solu√ß√£o parcial da palavra atual. Ela tem tamb√©m limita√ß√µes _- conforme visto anteriormente -_ e de acordo com as regras, a dica n√£o pode ser requerida pelo jogador caso:
> [...] a quantidade de letras reveladas seja inferior a 3 e que a palavra tenha mais de 4 letras em sua composi√ß√£o.

O primeiro caso, j√° est√° tratado na fun√ß√£o ``manipularEscolha()`` e o segundo caso tamb√©m est√° tratado na fun√ß√£o ``statusButton()``. Ent√£o o a fun√ß√£o ficou conforme a imagem abaixo.
![CODING_PROCESSAMENTO_DE_DADOS_4](https://user-images.githubusercontent.com/43553717/160299527-1b482160-d9e5-4cad-8ca9-d0723c99f7dd.jpg)

Como pode ver, √© gerado um indice aleat√≥rio dentro dos limites de ``palavraAtual`` e, enquanto a informa√ß√£o de que n√£o h√° correspond√™ncias dispon√≠veis no contexto onde as ``Label``s est√£o inseridas, requerida atrav√©s da fun√ß√£o ``letraDispon√≠vel()`` o indice gerado anteriormente recebe um novo indice aleat√≥rio. 

*- ``letraDispon√≠vel()`` retorna ``true`` caso a posi√ß√£o referente ao indice gerado est√° dispon√≠vel, isso √©, corresponde √† um caracter "_" e caso contr√°rio, retorna ``false``*.

E, quando houver uma posi√ß√£o dispon√≠vel, ela ser√° verificada atrav√©s do m√©todo ``verificarCodificacao()`` _- do qual falamos anteriormente -_ e atribuida a variavel local ``letraAtual`` e essa ser√° imediatamente passada para a fun√ß√£o ``manipularEscolha()`` _- do qual tamb√©m falamos anteriormente -_ **trocando todas as correspond√™ncias dessa letra na palavra atual** e mostrando o resultado parcial para o jogador.
Logo ap√≥s, o bot√£o refer√™nte √† letra gerada pela dica √© desativado _- pois n√£o h√° mais nenhuma correspond√™ncia desta letra na resolu√ß√£o_.

E agora s√≥ nos resta a **troca de palarva**. A troca de palavra, conforme solicitado nas regras, deve permitir ao jogador a:
> possibilidade de troca de palavra para outra do mesmo tema somente uma vez por rodada e na troca o n√∫mero de tentativas √© subtra√≠do por 2;

E √© exatamente isso que a fun√ß√£o ``manipularTrocaPalavra()`` descreve na imagem abaixo.
![CODING_PROCESSAMENTO_DE_DADOS_5](https://user-images.githubusercontent.com/43553717/160300135-b7a97358-3141-45b3-b430-02873a494329.jpg)

Em resumo, a uma nova palavra √© gerada e atribuida a variavel ``palavraAtual``, a fun√ß√£o ``esconderCorrespondencia()`` √© chamada para atualizar, no contexto das ``Label``s, a nova palavra gerada, os bot√µes s√£o novamente ativados _- inclusive a dica pois, sejamos justos, se o jogador pediu alguma dica, foi referente a palavra anterior... Por este motivo, as dicas que ele solicitou anteriormente s√£o in√∫teis nessa nova palavra -_, os acertos s√£o zerados, a fun√ß√£o de erro √© iterado duas vezes _- assim subtraindo o n√∫mero de tentativas por dois-_ e o bot√£o √© desativado _- pois o jogador s√≥ pode utilizar esse recurso uma vez por rodada._

E isso √© tudo por hoje p-p-pessoal! Chegamos ao fim deste readme. Espero que este pequeno resumo tenha ajudado a visualizar este projeto e lembre-se 
>**_"Ser ruim em alguma coisa √© o primeiro passo para se tornar bom em alguma coisa"_**

##### AT√â A PR√ìXIMA. FUI üòÅ
